---
layout: single
title: "Fortran and the Evolution of Programming Languages"
category: [coursework, programming-languages]
tag: COMP2007
author_profile: false
use_math: true
sidebar:
    nav: "counts"
---

Notes from the COMP2007 Lecture, and online resources.

## Context & Purpose
Let's revisit early programming languages like **Fortran**, with a focus on its 1977 revision, to explore how modern languages evolved. The focus is on the core principles of **readability, reliability, and writeability**, and how early systems shaped these attributes.

## Early Programming Challenges
- Programming was done in **machine code or assembly**, requiring manual memory addressing.
- Example: To set `X = 0`, you‚Äôd assign `0` to a memory address and reference that address, **fragile** and **error-prone**.

## The Shift Toward High-Level Languages
- **Interpreters** made higher-level languages like **BASIC** and later **Python** possible.
- Early interpreters were **slow**, especially for floating-point math, due to lack of hardware support.
- Despite inefficiencies, interpreters made programming more accessible.

## Language Evolution

| Language | Origin       | Purpose                                         |
|----------|--------------|-------------------------------------------------|
| BCPL     | 1960s        | System programming                              |
| B        | Late 1960s   | Simplified BCPL                                 |
| C        | Early 1970s  | Portable, efficient system language             |
| C++      | 1980s        | Object-oriented extension of C                  |
| D        | 2000s        | Modern systems language, not a direct successor |

- Understanding lineage helps explain the rise of modern languages: Java, Python, Swift, Rust, etc.
- Language choice should align with task requirements.

## C++ Conference: Matt Godbolt (2017)
Highlights:
- Compiler behavior and optimization.
- Registers in x86-64 (RDI, RSI, RDX, etc.), and SIMD registers (XMM, YMM, ZMM).
- ABI: Defines how functions communicate (e.g., arguments passed via RDI, RSI; return in RAX).
- Use of `LEA` for efficient memory address computation.
- XOR used to zero registers more efficiently than `MOV`.
- Modern compilers are smarter than manual optimization in many cases.

## Understanding x86-64 Architecture
- **Registers**: 16 general-purpose 64-bit registers.
- **ABI**: Arguments passed via RDI, RSI, etc. Return value in RAX.
- **Instructions**: Intel syntax (`dest ‚Üê src`), up to 3 operands.
- **Memory Access**: LEA allows address calculation without reading memory.
- **Compiler Optimization**: Modern compilers optimize using shift/add, LEA, XOR, etc.

## The Evolution of Fortran

### Fortran I (IBM 704)
- Released in **1957**.
- Machine-dependent, compiled language using **punch cards**.
- **Implicit Typing**: Variables beginning with I-N ‚Üí integers; others ‚Üí real.
- No modularity: Changes required recompiling the entire program.

### Fortran II
- Introduced **independent subroutine compilation**.
- Added `COMMON` blocks (global variable equivalent).
- Compilation was strict; students lost marks for each compile attempt.

### Fortran IV
- Introduced `IF` statement and **type declarations**.

### Fortran 77
- Major milestone: Introduced `DO` loops, `CHARACTER` type.
- Previously, control flow relied on various `GOTO` types.

### Modern Fortran
- Ongoing development: Fortran 95, 2003, 2008, etc.
- Still relevant in **scientific and HPC applications**.

## Why Fortran Was‚Äîand Still Is‚ÄîGreat

### 1. Early Efficiency
- First compiled language producing **fast machine code**.
- Efficient on early machines like the **IBM 704**.

### 2. Scientific & Numerical Strength
- Designed for **numerical computing**: strong with arrays, matrices, floating-point math.
- Widely used in **HPC**, simulations, physics, climate modeling.

### 3. Compiler Optimization
- Fortran compilers are **mature and optimized**.
- Outperform C/C++ in numerical domains.
- Efficiently leverage **x86-64**, SIMD (XMM/YMM/ZMM), and memory optimizations.

**Takeaway**: Fortran‚Äôs legacy continues in modern computing. Understanding its evolution offers insight into today‚Äôs programming landscape, from compilers and optimization to scientific computing.


--- 

As a computer science student, I find this kind of history truly interesting. It shows that just 30 to 40 years ago, people were coding in machine language and assembly, long before languages like C, Java, and Python existed.

The rise of AI, particularly generative transformers, is now enabling people to write code in natural language. I suspect that in another decade, many might view coding in Java or Python as a "low-level" task. It's possible that almost everyone will be coding in natural language, or maybe even the AI will be coding itself üòÖ